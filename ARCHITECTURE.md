


# Чтобы добавить новую страницу в приложение, нужно:
  - подредактировать класс `pages`, добавив новый идентификатор страницы `X_PAGE`
  - по аналогии с подобными методами добавить метод `is_X_page_active` для использования в коде методов ниже
  - отредактировать методы в файле `_viewer.py`
    - отрисовка
      - `_paintEvent`
    - обработка мыши
      - `mousePressEvent`
      - `mouseMoveEvent`
      - `mouseReleaseEvent`
      - `cursor_setter`
      - `wheelEvent`
      - `mouseDoubleClickEvent`
    - обработка клавиатуры
      - `keyReleaseEvent`
      - `keyPressEvent`
    - формирование контестного меню
      - `contextMenuEvent`
    - прочее
      - `resizeEvent`
        - реакция на изменение размеров окна
      - `on_timer`
        - главный таймер для анимации
      - `eventFilter`
        - удобный отлов всех сообщений
      - `toggle_to_frame_mode`
        - переключение в режим с рамкой
      - `change_page`
        - что делать, когда на эту страницу переключаются или когда с неё переключаются на другую
          - также отвечает за скрытие и показ панели управления при переключении страниц и настройке содержимого панели управления
  - отредактировать методы в файле `control_panel.py`
    - `ControlPanel`
      - `__init__`
        - для определения набора кнопок в панели управления для страницы
      - `paintEvent`
      - `thumbnails_drawing` и `thumbnails_click` написаны так, что зависят друг от друга
      - `wheelEvent`, `mousePressEvent`, `mouseMoveEvent`, `mouseReleaseEvent`
      - `contextMenuEvent`
  - отредактировать `settings_handling.py`
      - добавить строковой идентификатор настройки, тип настройки и текстовое описание к ней
      - доступ к настройке осуществляется по строковому идентификатору с префиксом `STNG_` через объект окна
      - изменение конкретной настройки программным путём (а не через окно настроек) не привоидит к автоматическому сохранению этой настройки, ведь это не всегда разумно, так как настройка может обновляться 100 раз в секунду. Для сохранения настройки нужно вызывать специальный метод из `settings_handling.py`
  - отредактировать `help_text.py` для добавления справки F1

# Особенности кодовой базы
  - обычно, мышь или клавиатура триггерят изменение элемента интерфейса, обновление его приватных данных, и косвенно вызывают функцию отрисовки через self.update(), а функция отрисовки paintEvent пользуется этими данными для выполнения отрисовки. Но в этой программе отрисовка главного окна и элементов на нём выполнена по-другому: в коде отрисовки элемента создаются и обновляются приватные данные, а в коде обработки мыши и клавиатуры они используются для разнообразных проверок, под конец этого кода косвенно вызывается перерисовка. Технически, из-за содержания лишнего кода в методе отрисовки FPS понижен, но на моём компе пока это не критично. Поздней я перепишу код, чтобы всё было как надо, но на раннем этапе (2022-й год) такой подход позволял легче писать код и отлаживать его, ведь это приложение ещё в 2022-м, да и всё ещё находится в статусе прототипа, и у него до сих пор не было ни одного релиза (сейчас январь 2026 года). 
    - всё вышеперечисленное не относится к окну настроек и прочим элементам интерфейса построенным на элементной базе фреймворка Qt


# Важно (для энтузиастов и программистов)

Из-за GIL в Си-шной реализации Python потоки QThread не работают так, как теоретически задумано, т.е. они выполняются по очереди, а не параллельно. Код обработки данных, например код создания превьюшек, с какого-то момента стал писаться исходя из того, что потоки выполняются по очереди, поэтому имейте ввиду, что при запуске в реальном многопоточном режиме могут появиться сбои, зависания и баги.
